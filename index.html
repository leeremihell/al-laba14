<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<title>Пошук максимальної пропускної здатності шляху (4 → 11)</title>
<style>
  body { font-family: sans-serif; }
  #graph { border: 1px solid #333; }
  #panel { width: 260px; margin-left: 20px; }
  #edgeList { max-height: 400px; overflow-y: auto; padding-left: 18px; }
  li { margin-bottom: 4px; }
</style>
</head>

<body>
<h2>Пошук шляху з максимальною пропускною здатністю у мережі (4 → 11)</h2>

<div style="display:flex; align-items:flex-start;">
  <canvas id="graph" width="800" height="540"></canvas>

  <div id="panel">
    <button id="stepBtn">Крок</button>

    <h3>Шляхи 4 → 11:</h3>
    <ul id="edgeList"></ul>

    <h3 id="finalFlow" style="color:blue;">Максимальна пропускна здатність: -</h3>
  </div>
</div>

<script>
// XML з flow та capacity
const xmlText = `
<graph_data>
<graph id="1">
<title>Graph</title>

<points>
    <point id="1" x="40" y="250" />
    <point id="2" x="200" y="100" />
    <point id="3" x="280" y="200" />
    <point id="4" x="200" y="420" />
    <point id="5" x="410" y="350" />
    <point id="6" x="400" y="130" />
    <point id="7" x="550" y="310" />
    <point id="8" x="620" y="170" />
    <point id="9" x="400" y="480" />
    <point id="10" x="610" y="450" />
    <point id="11" x="700" y="300" />
</points>

<lines>
    <line id="1" from="3" to="4" capacity="18" flow="2" />
    <line id="2" from="4" to="5" capacity="9" flow="8" />
    <line id="3" from="3" to="8" capacity="15" flow="9" />
    <line id="4" from="4" to="9" capacity="7" flow="4" />
    <line id="5" from="3" to="7" capacity="26" flow="8" />
    <line id="6" from="3" to="5" capacity="17" flow="3" />
    <line id="7" from="10" to="11" capacity="7" flow="5" />
    <line id="8" from="9" to="10" capacity="6" flow="6" />
    <line id="9" from="5" to="7" capacity="6" flow="3" />
    <line id="10" from="2" to="3" capacity="18" flow="2" />
    <line id="11" from="2" to="6" capacity="12" flow="3" />
    <line id="12" from="5" to="10" capacity="17" flow="7" />
    <line id="13" from="8" to="11" capacity="18" flow="10" />
    <line id="14" from="6" to="8" capacity="21" flow="20" />
    <line id="15" from="1" to="2" capacity="18" flow="10" />
    <line id="16" from="1" to="3" capacity="8" flow="8" />
    <line id="17" from="1" to="4" capacity="9" flow="8" />
    <line id="18" from="7" to="8" capacity="15" flow="9" />
    <line id="19" from="3" to="6" capacity="4" flow="3" />
</lines>

</graph>
</graph_data>
`;

// ------------------------------
//   Координати
// ------------------------------
const nodes = {};
{
  const xml = new DOMParser().parseFromString(xmlText, "application/xml");
  xml.querySelectorAll("point").forEach(p => {
    nodes[+p.getAttribute("id")] = {
      x: +p.getAttribute("x"),
      y: +p.getAttribute("y")
    };
  });
}

// ------------------------------
//   Ребра: зберігаємо capacity та flow
// ------------------------------
let edges = [];
let capacity = {};
let flow = {};
for (let i = 1; i <= 11; i++) {
  capacity[i] = {};
  flow[i] = {};
}

{
  const xml = new DOMParser().parseFromString(xmlText, "application/xml");
  xml.querySelectorAll("line").forEach(l => {
    let u = +l.getAttribute("from");
    let v = +l.getAttribute("to");
    let c = +l.getAttribute("capacity");
    let f = +l.getAttribute("flow");

    edges.push([u, v, c, f]);

    capacity[u][v] = c;
    capacity[v][u] = c;

    flow[u][v] = f;
    flow[v][u] = f;  // бо граф ненапрямлений
  });
}

// ------------------------------
//   Wide Path по остаткам (capacity - flow)
// ------------------------------

const SOURCE = 4;
const SINK = 11;

let currentPathEdges = [];
let bestWidth = -Infinity;
let bestPath = null;
let allPaths = [];
let pathIndex = 0;

// DFS для всех путей
function dfs(u, path, visited) {
  if (u === SINK) {
    allPaths.push(path.slice());
    return;
  }

  for (let v in capacity[u]) {
    v = +v;

    // Не идём по насыщенным рёбрам
    if (residual(u, v) <= 0) continue;

    if (!visited.has(v)) {
      visited.add(v);
      path.push(v);
      dfs(v, path, visited);
      path.pop();
      visited.delete(v);
    }
  }
}

// запускаем DFS
(function buildAllPaths() {
  let vis = new Set();
  vis.add(SOURCE);
  dfs(SOURCE, [SOURCE], vis);
})();

// остаток
function residual(u, v) {
  return capacity[u][v] - flow[u][v];
}

// минимальный остаток по пути
function minResidualOnPath(path) {
  let mn = Infinity;
  for (let i = 0; i < path.length - 1; i++) {
    mn = Math.min(mn, residual(path[i], path[i+1]));
  }
  return mn;
}

// шаг
function stepShowPaths() {
  if (pathIndex >= allPaths.length) {
    document.getElementById("stepBtn").disabled = true;
    return;
  }

  const path = allPaths[pathIndex++];
  const width = minResidualOnPath(path);

  currentPathEdges = [];
  for (let i = 0; i < path.length - 1; i++) {
    currentPathEdges.push([path[i], path[i+1]]);
  }

  const list = document.getElementById("edgeList");
  const li = document.createElement("li");
  li.textContent = `${path.join("-")} = ${width}`;
  list.appendChild(li);

  if (width > bestWidth) {
    bestWidth = width;
    bestPath = path.slice();
  }

  if (bestPath) {
    document.getElementById("finalFlow").textContent =
      `Максимальна пропускна здатність: ${bestPath.join("-")} = ${bestWidth}`;
  }

  draw();
}

// ------------------------------
//   Рисование
// ------------------------------
const canvas = document.getElementById("graph");
const ctx = canvas.getContext("2d");

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.strokeStyle = "#777";
  ctx.lineWidth = 1;
  ctx.font = "16px Arial";

  // рёбра с отображением flow/cap
  edges.forEach(([u, v, c, f]) => {
    const a = nodes[u], b = nodes[v];

    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();

    ctx.fillStyle = "black";
    ctx.fillText(`${f}/${c}`, (a.x + b.x) / 2, (a.y + b.y) / 2);
  });

  // подсветка пути
  ctx.strokeStyle = "blue";
  ctx.lineWidth = 4;
  currentPathEdges.forEach(([u, v]) => {
    const a = nodes[u], b = nodes[v];
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
  });

  // вершины
  for (let i = 1; i <= 11; i++) {
    const {x, y} = nodes[i];

    ctx.beginPath();
    ctx.arc(x, y, 19, 0, Math.PI*2);
    ctx.fillStyle = "white";
    ctx.fill();

    if (i === SOURCE || i === SINK) {
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 3;
    } else {
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
    }

    ctx.stroke();
    ctx.fillStyle = "black";
    ctx.fillText(i, x - 7, y + 7);
  }
}

draw();

document.getElementById("stepBtn").onclick = stepShowPaths;
</script>

</body>
</html>
