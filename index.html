<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<title>Пошук максимальної пропускної здатності шляху (4 → 11)</title>
<style>
  body { font-family: sans-serif; }
  #graph { border: 1px solid #333; }
  #panel { width: 260px; margin-left: 20px; }
  #edgeList { max-height: 400px; overflow-y: auto; padding-left: 18px; }
  li { margin-bottom: 4px; }
</style>
</head>

<body>
<h2>Пошук шляху з максимальною пропускною здатністю у мережі (4 → 11)</h2>

<div style="display:flex; align-items:flex-start;">
  <canvas id="graph" width="800" height="540"></canvas>

  <div id="panel">
    <button id="stepBtn">Крок</button>

    <h3>Шляхи 4 → 11:</h3>
    <ul id="edgeList"></ul>

    <h3 id="finalFlow" style="color:blue;">Максимальна пропускна здатність: -</h3>
  </div>
</div>

<script>
// XML (граф)
const xmlText = `
<graph_data>
<graph id="1">
<title>Graph</title>
<points>
	<point id="1" x="40" y="250" />
	<point id="2" x="200" y="100" />
	<point id="3" x="280" y="200" />
	<point id="4" x="200" y="420" />
	<point id="5" x="410" y="350" />
	<point id="6" x="400" y="130" />
	<point id="7" x="550" y="310" />
	<point id="8" x="620" y="170" />
	<point id="9" x="400" y="480" />
	<point id="10" x="610" y="450" />
	<point id="11" x="700" y="300" />
</points>
<lines>
	<line id="1" from="3" to="4" capacity="2" />
	<line id="2" from="4" to="5" capacity="8" />
	<line id="3" from="3" to="8" capacity="9" />
	<line id="4" from="4" to="9" capacity="4" />
	<line id="5" from="3" to="7" capacity="8" />
	<line id="6" from="3" to="5" capacity="3" />
	<line id="7" from="10" to="11" capacity="5" />
	<line id="8" from="9" to="10" capacity="6" />
	<line id="9" from="5" to="7" capacity="3" />
	<line id="10" from="2" to="3" capacity="2" />
	<line id="11" from="2" to="6" capacity="3" />
	<line id="12" from="5" to="10" capacity="7" />
	<line id="13" from="8" to="11" capacity="10" />
	<line id="14" from="6" to="8" capacity="20" />
	<line id="15" from="1" to="2" capacity="10" />
	<line id="16" from="1" to="3" capacity="8" />
	<line id="17" from="1" to="4" capacity="8" />
	<line id="18" from="7" to="8" capacity="9" />
	<line id="18" from="3" to="6" capacity="3" />
</lines>
</graph>
</graph_data>
`;

// ------------------------------
//   Координаты вершин
// ------------------------------
const nodes = {};
{
  const xml = new DOMParser().parseFromString(xmlText, "application/xml");
  xml.querySelectorAll("point").forEach(p => {
    const id = +p.getAttribute("id");
    nodes[id] = {
      x: +p.getAttribute("x"),
      y: +p.getAttribute("y")
    };
  });
}

// ------------------------------
//   Ребра и матрица capacity (БЕЗ остаточной сети)
// ------------------------------
let edges = [];
let capacity = {};
for (let i = 1; i <= 11; i++) capacity[i] = {};

{
  const xml = new DOMParser().parseFromString(xmlText, "application/xml");
  xml.querySelectorAll("line").forEach(l => {
    let u = +l.getAttribute("from");
    let v = +l.getAttribute("to");
    let c = +l.getAttribute("capacity");

    edges.push([u, v, c]);
    // граф НЕНАПРАВЛЕННЫЙ → делаем ребро двусторонним
    capacity[u][v] = c;
    capacity[v][u] = c;
  });
}

// ------------------------------
//   Переменные алгоритма
// ------------------------------
const SOURCE = 4;
const SINK = 11;

let currentPathEdges = [];   // путь, который сейчас подсвечиваем
let bestWidth = -Infinity;   // максимальная "пропускная способность" (максимум из минимумов)
let bestPath = null;         // путь с максимальной пропускной способностью
let allPaths = [];           // все простые пути из 4 в 11
let pathIndex = 0;           // какой путь сейчас показываем

// ------------------------------
//   DFS — поиск всех путей 4 → 11
// ------------------------------
function dfs(u, path, visited) {
  if (u === SINK) {
    allPaths.push(path.slice());
    return;
  }

  for (let v in capacity[u]) {
    v = +v;
    if (!visited.has(v)) {
      visited.add(v);
      path.push(v);
      dfs(v, path, visited);
      path.pop();
      visited.delete(v);
    }
  }
}

// считаем все пути один раз при старте
(function buildAllPaths() {
  let visited = new Set();
  visited.add(SOURCE);
  dfs(SOURCE, [SOURCE], visited);
})();

// ------------------------------
//   минимальная capacity по пути
//   (то, что ты называешь "пропускной способностью пути")
// ------------------------------
function minCapacityOnPath(path) {
  let minCap = Infinity;
  for (let i = 0; i < path.length - 1; i++) {
    let u = path[i];
    let v = path[i + 1];
    let c = capacity[u][v];
    if (c == null) return Infinity; // на всякий случай
    minCap = Math.min(minCap, c);
  }
  return minCap;
}

// ------------------------------
//   Один шаг: показать следующий путь
// ------------------------------
function stepShowPaths() {
  if (pathIndex >= allPaths.length) {
    // пути закончились — больше нечего показывать
    document.getElementById("stepBtn").disabled = true;
    return;
  }

  const path = allPaths[pathIndex++];
  const width = minCapacityOnPath(path); // "максимальна пропускна здатність" этого пути = минимум по рёбрам

  // подсветка текущего пути
  currentPathEdges = [];
  for (let i = 0; i < path.length - 1; i++) {
    currentPathEdges.push([path[i], path[i+1]]);
  }

  // лог
  const list = document.getElementById("edgeList");
  const li = document.createElement("li");
  li.textContent = path.join("-") + " = " + width;
  list.appendChild(li);

  // обновляем лучший путь (тот, у которого минимум по рёбрам максимальный)
  if (width > bestWidth) {
    bestWidth = width;
    bestPath = path.slice();
  }

  if (bestPath) {
    document.getElementById("finalFlow").textContent =
      "Максимальна пропускна здатність: " + bestPath.join("-") + " = " + bestWidth;
  }

  draw();
}

// ------------------------------
//   Отрисовка графа
// ------------------------------
const canvas = document.getElementById("graph");
const ctx = canvas.getContext("2d");

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // рёбра
  ctx.strokeStyle = "#777";
  ctx.lineWidth = 1;
  ctx.font = "18px Arial";

  edges.forEach(([u,v,w]) => {
    const a = nodes[u], b = nodes[v];
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
    ctx.fillStyle = "black";
    ctx.fillText(w, (a.x+b.x)/2, (a.y+b.y)/2);
  });

  // подсвеченный путь (синий)
  if (currentPathEdges.length > 0) {
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 4;
    currentPathEdges.forEach(([u,v]) => {
      const a = nodes[u], b = nodes[v];
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    });
  }

  // вершины — 4 и 11 выделяем синим
  for (let i = 1; i <= 11; i++) {
    const {x,y} = nodes[i];

    ctx.beginPath();
    ctx.arc(x, y, 19, 0, Math.PI*2);

    ctx.fillStyle = "white";
    ctx.fill();

    if (i === 4 || i === 11) {
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 3;
    } else {
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
    }

    ctx.stroke();
    ctx.fillStyle = "black";
    ctx.fillText(i, x-7, y+7);
  }
}

draw();

document.getElementById("stepBtn").onclick = stepShowPaths;
</script>

</body>
</html>
